//! Assembly Language Parser and Bytecode Generator
//!
//! This module implements an assembler that converts human-readable assembly code into
//! machine-executable bytecode. The assembly process happens in two passes:
//!
//! 1. First Pass:
//!    - Scans through the code to collect all labels and their addresses
//!    - Calculates the size of each instruction
//!    - Builds a symbol table for label references
//!
//! 2. Second Pass:
//!    - Converts each instruction into its binary representation
//!    - Resolves label references to actual addresses
//!    - Generates the final bytecode
//!
//! # Example Assembly Code
//! ```text
//! start:          ; A label that can be used as a jump target
//!     MOV r0, 5   ; Load value 5 into register 0
//!     ADD r0, r1  ; Add register 1 to register 0
//!     JMP start   ; Jump back to the start label
//! ```

mod error;
mod instruction;
mod parser;

pub use error::AssemblerError;
use parser::Parser;

/// The main assembler that converts assembly code into bytecode.
///
/// This struct coordinates the two-pass assembly process and provides
/// access to debugging information like label addresses.
pub struct Assembler
{
    parser: Parser,
}

impl Assembler
{
    /// Creates a new instance of the Assembler.
    ///
    /// # Example
    /// ```
    /// let assembler = Assembler::new();
    /// ```
    pub fn new() -> Self
    {
        Self { parser: Parser::new() }
    }

    /// Converts assembly code into bytecode.
    ///
    /// This is the main entry point for assembly. It takes assembly code as a string
    /// and returns either a vector of bytes (the bytecode) or an error if assembly fails.
    ///
    /// # Arguments
    /// * `code` - The assembly source code as a string
    ///
    /// # Returns
    /// * `Ok(Vec<u8>)` - The generated bytecode if assembly succeeds
    /// * `Err(AssemblerError)` - Details about what went wrong if assembly fails
    ///
    /// # Example
    /// ```
    /// let mut assembler = Assembler::new();
    /// let code = "
    ///     MOV r0, 5
    ///     ADD r0, r1
    ///     HALT
    /// ";
    /// match assembler.assemble(code) {
    ///     Ok(bytecode) => println!("Generated bytecode: {:?}", bytecode),
    ///     Err(e) => eprintln!("Assembly failed: {}", e),
    /// }
    /// ```
    pub fn assemble(&mut self, code: &str) -> Result<Vec<u8>, error::AssemblerError>
    {
        self.parser.assemble(code)
    }

    /// Returns a reference to the label-to-address mapping.
    ///
    /// This method is useful for debugging and understanding how labels
    /// are resolved to memory addresses.
    ///
    /// # Returns
    /// * A reference to the HashMap containing label names and their addresses
    pub fn labels(&self) -> &std::collections::HashMap<String, usize>
    {
        &self.parser.labels
    }
}
