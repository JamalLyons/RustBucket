//! Assembly code parser and bytecode generator
//!
//! This module handles the actual parsing of assembly code and conversion to bytecode.
//! It implements a two-pass assembly process:
//! 1. First pass collects labels and calculates instruction sizes
//! 2. Second pass generates the actual bytecode
//!
//! The parser handles:
//! - Comment removal (lines starting with ';')
//! - Label definitions (lines ending with ':')
//! - Instruction parsing (opcode and operands)
//! - Register validation
//! - Memory address resolution
//! - Label resolution

use std::collections::HashMap;

use super::error::AssemblerError;
use super::instruction::Instruction;

/// Parser for assembly code
///
/// Maintains state during the assembly process including:
/// - Collected instructions
/// - Label addresses
/// - Current address counter
pub struct Parser
{
    /// Instructions collected during first pass
    instructions: Vec<Instruction>,
    /// Map of label names to their addresses in memory
    pub labels: HashMap<String, usize>,
    /// Current address during assembly
    current_address: usize,
}

impl Default for Parser
{
    fn default() -> Self
    {
        Self::new()
    }
}

impl Parser
{
    /// Creates a new Parser instance with empty state
    pub fn new() -> Self
    {
        Self {
            instructions: Vec::new(),
            labels: HashMap::new(),
            current_address: 0,
        }
    }

    /// Main entry point for assembly process
    ///
    /// # Arguments
    /// * `code` - The assembly source code to process
    ///
    /// # Returns
    /// * `Result<Vec<u8>, AssemblerError>` - The generated bytecode or an error
    pub fn assemble(&mut self, code: &str) -> Result<Vec<u8>, AssemblerError>
    {
        self.first_pass(code)?;
        self.second_pass()
    }

    /// First pass of assembly - collect labels and calculate addresses
    ///
    /// This pass:
    /// 1. Processes each line of code
    /// 2. Collects label definitions and their addresses
    /// 3. Parses instructions to calculate their sizes
    /// 4. Builds the instruction list for the second pass
    fn first_pass(&mut self, code: &str) -> Result<(), AssemblerError>
    {
        self.current_address = 0;
        self.instructions.clear();
        self.labels.clear();

        for line in code.lines() {
            let line = line.trim();

            // Skip empty lines and comments
            if line.is_empty() || line.starts_with(';') {
                continue;
            }

            // Handle labels (lines ending with ':')
            if line.ends_with(':') {
                let label = &line[..line.len() - 1].trim();
                self.validate_label(label)?;
                self.labels.insert(label.to_string(), self.current_address);
                continue;
            }

            // Parse instruction
            let inst = line.parse::<Instruction>()?;
            self.current_address += self.calculate_instruction_size(&inst);
            self.instructions.push(inst);
        }
        Ok(())
    }

    /// Calculates how many bytes an instruction will occupy in memory
    ///
    /// # Arguments
    /// * `inst` - The instruction to analyze
    ///
    /// # Returns
    /// * `usize` - Number of bytes needed for this instruction
    fn calculate_instruction_size(&self, inst: &Instruction) -> usize
    {
        // Get the size from the encoded instruction
        inst.encode().map(|bytes| bytes.len()).unwrap_or(0)
    }

    /// Performs the second pass of assembly, generating the final bytecode
    ///
    /// This pass:
    /// 1. Validates each instruction's operands
    /// 2. Converts instructions to their binary representation
    /// 3. Resolves all label references to addresses
    ///
    /// # Returns
    /// * `Result<Vec<u8>, AssemblerError>` - The complete program bytecode
    fn second_pass(&self) -> Result<Vec<u8>, AssemblerError>
    {
        let mut bytecode = Vec::new();
        let mut current_addr = 0;

        for inst in &self.instructions {
            // Clone the instruction bytes since we might need to modify them
            let mut inst_bytes = inst.encode()?;

            // If this is a jump/call instruction, resolve the label
            match inst.opcode.as_str() {
                "JMP" | "JEQ" | "JGT" | "JNE" | "CALL" => {
                    if let Some(label) = inst.operands.first() {
                        // Check if the operand is a label (not a numeric value)
                        if !label.starts_with("0x") && !label.chars().next().unwrap().is_numeric() {
                            if let Some(&addr) = self.labels.get(label) {
                                // Update the address in the instruction bytes
                                inst_bytes[1] = addr as u8;
                            } else {
                                return Err(AssemblerError::UndefinedLabel(label.clone()));
                            }
                        }
                    }
                }
                _ => {}
            }

            // Keep track of current address for label resolution
            current_addr += inst_bytes.len();

            // Add the instruction bytes to the final bytecode
            bytecode.extend_from_slice(&inst_bytes);
        }

        Ok(bytecode)
    }

    /// Validates a label name
    ///
    /// Labels must:
    /// - Not be empty
    /// - Not start with a number
    /// - Contain only alphanumeric characters and underscores
    ///
    /// # Arguments
    /// * `label` - The label name to validate
    ///
    /// # Returns
    /// * `Result<(), AssemblerError>` - Ok if valid, Err if invalid
    fn validate_label(&self, label: &str) -> Result<(), AssemblerError>
    {
        if label.is_empty() {
            return Err(AssemblerError::InvalidLabel("Empty label".to_string()));
        }

        if label.chars().next().unwrap().is_numeric() {
            return Err(AssemblerError::InvalidLabel(format!(
                "Label cannot start with a number: {}",
                label
            )));
        }

        if !label.chars().all(|c| c.is_alphanumeric() || c == '_') {
            return Err(AssemblerError::InvalidLabel(format!(
                "Label contains invalid characters: {}",
                label
            )));
        }

        Ok(())
    }

    fn parse_instruction(&mut self, tokens: &[&str]) -> Result<Instruction, AssemblerError>
    {
        match tokens[0].to_uppercase().as_str() {
            // ... existing matches ...
            "HALT" | "HLT" => {
                if tokens.len() != 1 {
                    return Err(AssemblerError::InvalidInstruction("HALT takes no arguments".to_string()));
                }
                Ok(Instruction::new("HALT".to_string(), vec![]))
            }
            // ... rest of the matches ...
            _ => Err(AssemblerError::InvalidInstruction(format!(
                "Unknown instruction: {}",
                tokens[0]
            ))),
        }
    }
}
